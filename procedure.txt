# 1️⃣ Refine the backend **first** (Day 1)

**Reason:**

* Backend is the **core of your stack**: MongoDB + encryption + blockchain hash storage.
* All frontend and IPFS work will **depend on backend APIs**.
* If the backend is messy or buggy, everything else breaks.

**Actions:**

1. **Refactor your current backend structure**

   * Split `server.js` → `server.js` + `app.js`
   * Add `controllers/complaintsController.js` for complaint logic
   * Add `routes/complaints/index.js` for REST endpoints
   * Add `middleware/errorHandler.js`
   * Optional: `middleware/auth.js` for future user/admin auth

2. **Implement core complaint APIs**

   * `POST /complaints` → receives complaint + image(s)
   * `GET /complaints` → returns list of complaints (metadata + CID + hash)
   * Optional: `PUT /complaints/:id/status` → for admin to update status

3. **Integrate IPFS upload** (can be Pinata for simplicity)

   * Upload images
   * Receive CID
   * Compute hash of (complaintID + description + CID) → ready for blockchain

4. **Store everything in MongoDB**

   * Complaint metadata + CID + hash + timestamp + status
   * This ensures **queryable storage for frontend**

5. **Hook blockchain integration** (optional at first)

   * For MVP, you can first **store the hash in DB**
   * Then in the next step, **send hash to smart contract**

✅ By end of this step, your **backend + MongoDB + IPFS** is fully functional.

---

# 2️⃣ Smart Contract (Day 2)

**Reason:**

* Blockchain integration is critical but small — only stores **hash + timestamp + complaintID**
* You want to deploy to **Polygon Mumbai testnet** for demo

**Actions:**

1. Write Solidity contract `ComplaintHash.sol`

   * `storeHash(hash, complaintID, reporterWallet)`
   * `updateStatus(complaintID)` → admin only
   * `verifyHash(complaintID)` → returns stored hash

2. Deploy contract using Hardhat or Truffle

3. Add **unit tests** (Hardhat) to ensure `storeHash` & `verifyHash` work

✅ By the end, you have a **working blockchain layer**.

---

# 3️⃣ Backend → Blockchain Integration (Day 3)

* After storing in MongoDB, send **hash to smart contract**
* Optional: catch transaction receipt → store `txHash` in MongoDB
* Ensure **errors are caught** → if blockchain call fails, backend still stores locally

✅ Backend now handles **MongoDB + IPFS + blockchain**

---

# 4️⃣ Frontend (Day 4)

**Reason:**

* Now backend is fully functional, frontend can **consume APIs**
* Start with simple UI, then connect Web3

**Actions:**

1. Complaint form: file upload + description + location
2. Submit → calls backend → receives confirmation + CID + hash
3. Complaint list: fetch from backend → display metadata + blockchain verification status
4. Optional: listen to smart contract events for real-time updates

---

# 5️⃣ Polish & Testing (Day 5)

* Test full flow: **frontend → backend → IPFS → blockchain → frontend display**
* Fix UI bugs, loading indicators
* Add **README, screenshots, demo instructions**
* Prepare **presentation / demo flow**

---

# ⚡ My Mentor’s Strict Advice

1. **Do not start frontend before backend** → you’ll waste time on dummy APIs
2. **Do not start smart contract before backend** → blockchain is useless if hash generation is wrong
3. **Do not skip IPFS integration** → images are core to your project
4. **Focus on a working MVP first**, then polish UI and admin features
5. **Write minimal tests** to avoid crashes during demo
